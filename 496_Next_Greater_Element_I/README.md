### 496.下一个更大的元素 I

`nums1` 中数字 `x` 的 **下一个更大元素** 是指 `x` 在 `nums2` 中对应位置 **右侧** 的 **第一个** 比 `x` 大的元素。

给你两个 **没有重复元素** 的数组 `nums1` 和 `nums2` ，下标从 **0** 开始计数，其中`nums1` 是 `nums2` 的子集。

对于每个 `0 <= i < nums1.length` ，找出满足 `nums1[i] == nums2[j]` 的下标 `j` ，并且在 `nums2` 确定 `nums2[j]` 的 **下一个更大元素** 。如果不存在下一个更大元素，那么本次查询的答案是 `-1` 。

返回一个长度为 `nums1.length` 的数组 `ans` 作为答案，满足 `ans[i]` 是如上所述的 **下一个更大元素** 。

来源：力扣

https://leetcode.cn/problems/next-greater-element-i/



思路：

​			要记录后出现的比前出现的数字第一次大的位置和数值，符合单调栈的特性。

​			建立一个`unordered_map`类型的变量`next`，一个`stack`类型的变量`st`，分别用于存放每个`key`对应的下一个更大元素、降序排列的栈。

​		遍历`nums2`，在`st`不为空且`st.top()<n`的条件下，当满足此条件时，执行如下代码：

```c
		next[st.top()] = n;
    st.pop();
```

​		否则的话，说明`n`小于当前栈顶元素，仍旧需要压栈，继续寻找符合条件的额元素：`st.push(n)`。

​		定义数组`ans`，长度为`nums1.size()`，将所有元素都初始化为-1。遍历整个`nums1`数组，定义`n=nums1[i]`，如果`next.count(n)`不为0，设置`ans[i] = next[n]`。

​		返回值就是`ans`。