### 1466.重新规划路线

`n` 座城市，从 `0` 到 `n-1` 编号，其间共有 `n-1` 条路线。因此，要想在两座不同城市之间旅行只有唯一一条路线可供选择（路线网形成一颗树）。去年，交通运输部决定重新规划路线，以改变交通拥堵的状况。

路线用 `connections` 表示，其中 `connections[i] = [a, b]` 表示从城市 `a` 到 `b` 的一条有向路线。

今年，城市 0 将会举办一场大型比赛，很多游客都想前往城市 0 。

请你帮助重新规划路线方向，使每个城市都可以访问城市 0 。返回需要变更方向的最小路线数。

题目数据 **保证** 每个城市在重新规划路线方向后都能到达城市 0 。

来源：力扣

https://leetcode.cn/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/description/



思路：

​		考虑从节点0出发到达其他所有节点，方向与题目描述相反，因此，在构建图的时候，低于有向边[a,b]，应该被视为[b,a]，也就是说，如果要从a到b，需要变更一次方向，如果从b到a，不需要变更方向。

​		首先构建数组`e(n)`，存放`connections`中所有的`edge[0]`以及他对应的所有的`edge[1]`，包含方向。有向边的前面节点在`e`中存储为：`e[edge[0]].push_back(make_pair(edge[1],1))`，有向边的后面节点在`e`中存储为：`e[edge[1]].push_back(make_pair(edge[0],0))`。

​		深度优先遍历时，需要传入当前节点、当前节点的父节点以及存储节点关系的数组`e`。定义`res`，用于统计需要变更的最小边数，从节点0搜索到其他所有节点。在`e`中找到与当前节点存在关联的所有节点数组`e[x]`，对于`e[x]`中的所有`edge`而言，如果`edge.first==parent`，直接`continue`，因为最终目的就是需要将节点方向改为指向根节点。否则的话，需要在`res`中加上`edge.second`和`dfs(edge.first,x,e)`。