### 2008.出租车的最大盈利

你驾驶出租车行驶在一条有 `n` 个地点的路上。这 `n` 个地点从近到远编号为 `1` 到 `n` ，你想要从 `1` 开到 `n` ，通过接乘客订单盈利。你只能沿着编号递增的方向前进，不能改变方向。

乘客信息用一个下标从 **0** 开始的二维数组 `rides` 表示，其中 `rides[i] = [starti, endi, tipi]` 表示第 `i` 位乘客需要从地点 `starti` 前往 `endi` ，愿意支付 `tipi` 元的小费。

**每一位** 你选择接单的乘客 `i` ，你可以 **盈利** `endi - starti + tipi` 元。你同时 **最多** 只能接一个订单。

给你 `n` 和 `rides` ，请你返回在最优接单方案下，你能盈利 **最多** 多少元。

**注意：**你可以在一个地点放下一位乘客，并在同一个地点接上另一位乘客。

来源：力扣

https://leetcode.cn/problems/maximum-earnings-from-taxi/



思路：

​	首先定义数组`groups`，用于存放盈利关系：

```c
		for(auto &r : rides){
			int start = r[0],end = r[1],tip = r[2];
      groups[end].emplace_back(start,end-start+tip);
    }
```

​	要解决的问题都是从1开始开到`i`，因此定义`dfs(i)`表示从1开到`i`最多可以赚多少钱。如果`i==1`，直接返回0即可。如果没有乘客在`i`下车，或者不载在`i`下车的乘客，问题变成：从1开到`i-1`最多可以赚多少钱，即`dfs(i)=dfs(i-1)`。如果至少有一位乘客在`i`下车，就利用枚举的办法，找到载哪位乘客最赚钱：

```c
		res = dfs(i-1);
    for(auto& [s,t] : groups[i]){
    	res = max(res, dfs(s)+t);
    }
```

​	定义数组`memo(n+1,-1)`，用于实现记忆化搜索，如果一个状态是第一次遇到，那么在返回前，把状态及结果记录到一个`memo`数组中，如果不是第一次遇到（`memo`中保存的结果不是-1），直接返回`memo`中保存的那个结果即可。

​		最终结果应该为`dfs(n)`。

​	

​	