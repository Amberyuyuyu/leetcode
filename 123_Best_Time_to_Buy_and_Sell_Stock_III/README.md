### 123.买卖股票的最大时机III

给定一个数组，它的第 `i` 个元素是一支给定的股票在第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 **两笔** 交易。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

来源：力扣

https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/



思路：

​		动态规划。

​		如果`prices`的大小为0，直接返回0即可。

​		定义`dp`数组，维度是`prices.size()*5`，将所有元素都初始化为0。这个5表示五个状态：

​		(0) 没有操作；

​		(1) 第一次持有股票；

​		(2)第一次不持有股票；

​	    (3)第二次持有股票；

​		(4) 第二次不持有股票。

​		`dp[i][j]`表示第`i`天，`j`为[0-4]五个状态。`dp[i][j]`代表第`i`天状态`j`所剩最大现金。

​		达到`dp[i][1]`状态：

​				如果第`i`天买入股票，那么`dp[i][1]=dp[i-1][0]-prices[i]`。

​				第`i`天没有操作，那么就沿用第`i-1`天的状态，`dp[i][j]=dp[i-1][1]`。

​				在这两者中取最大值：`dp[i][1] = max(dp[i-1][0]-prices[i],dp[i-1][1])`。

​		达到`dp[i][2]`状态：

​				如果第`i`天卖出股票，那么`dp[i][2]=dp[i-1][1]+prices[i]`；

​				如果第`i`天没有操作，那么`dp[i][2]=dp[i-1][2]`。

​				在这两者中取最大值：`dp[i][2]=max(dp[i-1][1]+prices[i],dp[i-1][2])`。

​	同理，计算`dp[i][3]=dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i])`，`dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i])`。	

​				最终返回值一定为卖出股票状态，只有卖出状态下才会出现最大值。

​		