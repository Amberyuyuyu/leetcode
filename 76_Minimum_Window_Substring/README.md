### 76.最小覆盖子串

给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

来源：力扣

https://leetcode.cn/problems/minimum-window-substring/



思路：

​		滑动窗口。

​		定义两个unordered_map类型的变量`hs`和`ht`，遍历`t`，统计`t`中每个元素出现的次数到`ht`中。定义字符串`res`，用于表示最终结果。定义变量`i`，用于遍历字符串`s`时延伸窗口，变量`j`用于收缩窗口，区间[j,i]表示当前滑动窗口，两个变量均初始化为0。在遍历时，每次都执行`hs[s[i]]++`，如果`hs[s[i]]<=ht[s[i]]`，说明现存的字母`s[i]`的个数还未达到`t`中该字符的数目要求。执行`cnt++`，如果`hs[s[j]]>ht[s[j]]`，说明此时窗口内s[j]数量多于t中s[j]的数量，需要收缩窗口：`hs[s[j++]]--`。当`cnt==t.size()`时，说明此时窗口包含了`t`中所有元素，如果此时`res`为空或者`i-j+1<res.size()`，就从`s`中提取j为起始位置的长度为`i-j+1`的字符串作为`res`。



​		