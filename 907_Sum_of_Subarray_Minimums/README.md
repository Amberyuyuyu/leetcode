### 907.子数组的最小值之和

给定一个整数数组 `arr`，找到 `min(b)` 的总和，其中 `b` 的范围为 `arr` 的每个（连续）子数组。

由于答案可能很大，因此 **返回答案模 `10^9 + 7`** 。

来源：力扣

https://leetcode.cn/problems/sum-of-subarray-minimums/



思路：

​		对每个数，算出它是哪些数组的最小值，以2为例，2为最小值的子数组，绝对不能包含比2小的以及等于2的数字，找到2左右两侧小于等于它的数的下标，从而确定子数组的边界。

​		设arr[i]对应的边界为开区间(L, R)，由于子数组必须包含arr[i]：

 - 子数组的左端点可以是L+1, L+2, ... , i，共有i-L个；
 - 子数组的右端点可以是i, i+1, ... , R-1，共有R-i个。

​		那么以arr[i]为最小值的子数组的个数为(i-L)*(R-i)。

​		定义`n`为`arr`的大小，定义数组`left`和`right`，分别用于存放每个元素对应的左右边界。计算左右边界时，以计算左边界为例，从左到右遍历数组，利用栈来维护遍历过的元素，并及时移除无用的元素。当满足栈不为空并且栈顶元素大于当前元素时，一直执行弹栈操作。不满足条件时，可以得到`left[i] = st.empty() ? -1 : st.top()`。然后将`i`入栈。

​		清空栈后，再计算`right`，当满足栈不为空并且`arr[st.top()]>=arr[i]`时，执行弹栈操作。不满足条件以后，`right[i]=st.empty() ? n : st.top()`，然后将`i`入栈。

​		计算结果时，为避免溢出，定义长长整形变量`result`，初始化为0，定义`mod=1e9+7`，遍历`arr`数组，每次都执行`result =(result+(long long)arr[i]*(i-left[i])*(right[i]-i))%mod`，最终返回值为`result`。