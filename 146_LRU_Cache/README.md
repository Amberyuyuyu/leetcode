### 146.LRU缓存

请你设计并实现一个满足 [LRU (最近最少使用) 缓存](https://baike.baidu.com/item/LRU) 约束的数据结构。

实现 `LRUCache` 类：

- `LRUCache(int capacity)` 以 **正整数** 作为容量 `capacity` 初始化 LRU 缓存
- `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 `-1` 。
- `void put(int key, int value)` 如果关键字 `key` 已经存在，则变更其数据值 `value` ；如果不存在，则向缓存中插入该组 `key-value` 。如果插入操作导致关键字数量超过 `capacity` ，则应该 **逐出** 最久未使用的关键字。

函数 `get` 和 `put` 必须以 `O(1)` 的平均时间复杂度运行。

来源：力扣

https://leetcode.cn/problems/lru-cache/



思路：

​		LRU缓存的特点：（1）给定`key`值获取`value`值时，如果存在这个键值，就将其从原位置移除，并将其放置在最末位的位置，如果不存在这个键值，直接返回-1即可；（2）在加入健值对时，如果该键值在原数据结构中出现过，删除原键值对，将新的键值对插入原数据结构。如果原数据结构不存在这个键，并且此时数据结构已经装满，就将最前端的键值对移除，将新的键值对加入到数据结构末尾。如果此时数据结构未满，直接插入到其尾部即可。

​		根据该数据结构以上的特点，需要一个双向链表和一个`map`来实现。每一个节点都有键和值，还包含一个`prev`指针和一个`next`指针，分别指向它的前一个节点和后一个节点。