### 1027.最长等差数列

给你一个整数数组 `nums`，返回 `nums` 中最长等差子序列的**长度**。

回想一下，`nums` 的子序列是一个列表 `nums[i1], nums[i2], ..., nums[ik]` ，且 `0 <= i1 < i2 < ... < ik <= nums.length - 1`。并且如果 `seq[i+1] - seq[i]`( `0 <= i < seq.length - 1`) 的值都相同，那么序列 `seq` 是等差的。

来源：力扣

https://leetcode.cn/problems/longest-arithmetic-subsequence/



思路：

​		动态规划。

​		定义`n=nums.size()`，定义动态规划数组`f[n][1001]`，第一个维度代表数组元素个数，1001代表公差可能出现的所有情况：-500～500，一共有1001个。`f[i][j]`代表的是到`nums[i]`为止，公差为`j`时等差数列中元素个数。将`f`所有元素都初始化为0。定义`ans`变量，用于存放最终结果。定义两个变量`i`和`k`，分别表示子序列的右端点下标和左端点下标。由于`nums[i]`都满足`0<=nums[i]<=500`，因此可能存在后面的数字小于前面的情况，等差数列的差可能为负数，因此，在求`nums[i]-nums[k]`时，将差加上500，可以把所有项转为正数，避免产生负数下标（第二维度下标）。定义`j=nums[i]-nums[k]+500`，`f[i][j] = f[k][j]+1`，`ans=max(ans，f[i][j])`。

​	由于初始化`f`所有元素都为0，因此最后需要在`ans`上加1。