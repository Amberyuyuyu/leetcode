### 1488.避免洪水泛滥

你的国家有无数个湖泊，所有湖泊一开始都是空的。当第 `n` 个湖泊下雨前是空的，那么它就会装满水。如果第 `n` 个湖泊下雨前是 **满的** ，这个湖泊会发生 **洪水** 。你的目标是避免任意一个湖泊发生洪水。

给你一个整数数组 `rains` ，其中：

- `rains[i] > 0` 表示第 `i` 天时，第 `rains[i]` 个湖泊会下雨。
- `rains[i] == 0` 表示第 `i` 天没有湖泊会下雨，你可以选择 **一个** 湖泊并 **抽干** 这个湖泊的水。

请返回一个数组 `ans` ，满足：

- `ans.length == rains.length`
- 如果 `rains[i] > 0` ，那么`ans[i] == -1` 。
- 如果 `rains[i] == 0` ，`ans[i]` 是你第 `i` 天选择抽干的湖泊。

如果有多种可行解，请返回它们中的 **任意一个** 。如果没办法阻止洪水，请返回一个 **空的数组** 。

请注意，如果你选择抽干一个装满水的湖泊，它会变成一个空的湖泊。但如果你选择抽干一个空的湖泊，那么将无事发生。

来源：力扣

https://leetcode.cn/problems/avoid-flood-in-the-city/



思路：

​		本题核心在于找到每个湖泊两次下雨之间最早的晴天。无法阻止洪水：第`i`天下雨的湖泊`rains[i]`是满的，前面没有晴天可以把它抽干。当下雨湖泊与之前下雨的天数之间没有晴天时，会发生洪水。

​		因此，只要两次下雨之间有晴天，就一定不会发生洪水。如果存在多个晴天，优先考虑最早的晴天进行抽干，把靠后的晴天留给更以后下雨的湖泊。定义数组`ans`，将所有元素都初始化为-1，用于表示最终结果。

​		定义有序集合`sunnyDays`，用于记录可用的晴天，定义`lakeLastRain`，记录每个湖泊上下雨的时间。定义变量`n`为`rains.size()`，通过变量`i`遍历整个`rains`数组，每次都定义`lake=rains[i]`，如果`lake=0`，将i加入到`sunnyDays`中，`ans[i]=1`，使得剩余可用晴天默认抽干一号湖泊。如果`lake>0`，如果这个湖泊之前也下过雨，就要两个下雨的区间内找到最早的不下雨天来抽空这个湖泊，如果没有晴天，就直接返回`{}`，表示洪水无法避免。否则，`ans[*it]=lake`，将`it`从`sunnyDays`中移除。