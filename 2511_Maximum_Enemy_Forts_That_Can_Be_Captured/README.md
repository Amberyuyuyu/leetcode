### 2511.最多可以摧毁的敌人城堡数目

给你一个长度为 `n` ，下标从 **0** 开始的整数数组 `forts` ，表示一些城堡。`forts[i]` 可以是 `-1` ，`0` 或者 `1` ，其中：

- `-1` 表示第 `i` 个位置 **没有** 城堡。
- `0` 表示第 `i` 个位置有一个 **敌人** 的城堡。
- `1` 表示第 `i` 个位置有一个你控制的城堡。

现在，你需要决定，将你的军队从某个你控制的城堡位置 `i` 移动到一个空的位置 `j` ，满足：

- `0 <= i, j <= n - 1`
- 军队经过的位置 **只有** 敌人的城堡。正式的，对于所有 `min(i,j) < k < max(i,j)` 的 `k` ，都满足 `forts[k] == 0` 。

当军队移动时，所有途中经过的敌人城堡都会被 **摧毁** 。

请你返回 **最多** 可以摧毁的敌人城堡数目。如果 **无法** 移动你的军队，或者没有你控制的城堡，请返回 `0` 。

来源：力扣

https://leetcode.cn/problems/maximum-enemy-forts-that-can-be-captured/



思路：

​		定义变量`ret`，初始化为0。定义变量`pre`，表示下标，初始化为-1。

​		定义变量`i`，用于遍历数组`forts`，如果遇到`forts[i]==1`或者`forts[i]==-1`，就判断`pre`现在是否大于0(是否已经在这个`i`之前遇到过`forts[i]!=0`的情况),如果此时`pre>0`并且`forts[pre]!=forts[i]`，判断此时的`ret`和`i-pre-1`的大小，将较大值作为新的`ret`。只要`forts[i]==1`或-1，就将`pre`改为现在的`i`。在遍历完以后，将`ret`返回。