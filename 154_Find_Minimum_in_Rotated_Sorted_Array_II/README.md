### 154.寻找旋转数组中的最小值II

已知一个长度为 `n` 的数组，预先按照升序排列，经由 `1` 到 `n` 次 **旋转** 后，得到输入数组。例如，原数组 `nums = [0,1,4,4,5,6,7]` 在变化后可能得到：

- 若旋转 `4` 次，则可以得到 `[4,5,6,7,0,1,4]`
- 若旋转 `7` 次，则可以得到 `[0,1,4,4,5,6,7]`

注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` **旋转一次** 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` 。

给你一个可能存在 **重复** 元素值的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 **最小元素** 。

你必须尽可能减少整个过程的操作步骤。

来源：力扣

https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/



思路：

​		定义`n`为`nums`的长度。

​		如果`nums[0]<nums[n-1]`，说明经过旋转后的数组与原数组完全相同，直接返回`nums[0]`即可。

​		定义变量`i`和`j`，分别初始化为0和`n-1`。当满足`i<j`时，定义`mid=left+(right-left)/2`，如果`nums[mid]>nums[j]`，说明`mid`位于第一个升序序列，定义`i=mid+1`，最小的数字应该出现在`[mid+1,j]`之间。如果`nums[mid]<nums[j]`，说明`mid`位于第二个升序序列，最小数字应该在`mid`的位置或者`mid`之前的位置，此时应该有`j=mid`。如果`nums[mid]`与`nums[j]`相等，执行`j--`即可。

​		最终返回`nums[i]`即可。